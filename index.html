<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Verilog HDL Programs Collection</title>
<style>
    body {
        font-family: "Segoe UI", Tahoma, sans-serif;
        background-color: #121212;
        color: #e0e0e0;
        line-height: 1.5;
        margin: 40px;
    }
    h2 {
        color: #00e676;
        border-bottom: 2px solid #00e676;
        padding-bottom: 5px;
    }
    pre {
        background-color: #1e1e1e;
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
        color: #dcdcdc;
        font-family: "Consolas", "Courier New", monospace;
        font-size: 14px;
    }
    code {
        color: #ffcc80;
    }
</style>
</head>
<body>

<h1>Verilog HDL Programs Collection</h1>

<h2>Encoder</h2>
<pre><code>
module prog_1(
    input [7:0] d,
    output reg [2:0] y
);
    always @(*) begin
        case(d)
            8'b00000001: y = 3'b000;
            8'b00000010: y = 3'b001;
            8'b00000100: y = 3'b010;
            8'b00001000: y = 3'b011;
            8'b00010000: y = 3'b100;
            8'b00100000: y = 3'b101;
            8'b01000000: y = 3'b110;
            8'b10000000: y = 3'b111;
        endcase
    end
endmodule

module prog_1_tb;
    reg [7:0] d;
    wire [2:0] y;
    prog_1 uut(d, y);
    initial begin
        d = 8'b00000001; #10;
        d = 8'b00000010; #10;
        d = 8'b00000100; #10;
        d = 8'b00001000; #10;
        d = 8'b00010000; #10;
        d = 8'b00100000; #10;
        d = 8'b01000000; #10;
        d = 8'b10000000; #10;
    end
endmodule
</code></pre>

<h2>Half Adder & Full Adder</h2>
<pre><code>
module half_adder(a,b,s,c);
    input a,b;
    output s,c;
    assign s = a ^ b;
    assign c = a & b;
endmodule

module prog_1(A,B,Cin,sum,Cout);
    input A,B,Cin;
    output sum,Cout;
    wire sum_1,c1;
    half_adder HA1(.a(A),.b(B),.s(sum_1),.c(c1));
    half_adder HA2(.a(sum_1),.b(Cin),.s(sum),.c(Cout));
endmodule

module prog_1_tb;
    reg A,B,Cin;
    wire sum,Cout;
    prog_1 uut(A,B,Cin,sum,Cout);
    initial begin
        A=0;B=0;Cin=0;#10;
        A=0;B=0;Cin=1;#10;
        A=0;B=1;Cin=0;#10;
        A=0;B=1;Cin=1;#10;
        A=1;B=0;Cin=0;#10;
        A=1;B=0;Cin=1;#10;
        A=1;B=1;Cin=0;#10;
        A=1;B=1;Cin=1;#10;
    end
endmodule
</code></pre>

<h2>Demultiplexer (1x8 DEMUX)</h2>
<pre><code>
module prog_1(
    input d, 
    input [2:0] sel,
    output [7:0] y
);
    assign y[0]=d&(~sel[0])&(~sel[1])&(~sel[2]);
    assign y[1]=d&(~sel[0])&(~sel[1])&(sel[2]);
    assign y[2]=d&(~sel[0])&(sel[1])&(~sel[2]);
    assign y[3]=d&(~sel[0])&(sel[1])&(sel[2]);
    assign y[4]=d&(sel[0])&(~sel[1])&(~sel[2]);
    assign y[5]=d&(sel[0])&(~sel[1])&(sel[2]);
    assign y[6]=d&(sel[0])&(sel[1])&(~sel[2]);
    assign y[7]=d&(sel[0])&(sel[1])&(sel[2]);
endmodule

module prog_1_tb;
    reg d;
    reg [2:0] sel;
    wire [7:0] y;
    prog_1 uut(d,sel,y);
    initial begin
        d=1; sel=3'b000; #10;
        d=1; sel=3'b001; #10;
        d=1; sel=3'b010; #10;
        d=1; sel=3'b011; #10;
        d=1; sel=3'b100; #10;
        d=1; sel=3'b101; #10;
        d=1; sel=3'b110; #10;
        d=1; sel=3'b111; #10;
    end
endmodule
</code></pre>

<h2>4-bit Parallel Adder</h2>
<pre><code>
module full_adder(a,b,cin,s,cout);
    input a,b,cin;
    output s,cout;
    assign s=a^b^cin;
    assign cout=(a&b)|(b&cin)|(a&cin);
endmodule

module prog_1(input [3:0]A, input [3:0]B, input C, output [3:0]sum, output cout);
    wire c1,c2,c3;
    full_adder FA1(A[0],B[0],C,sum[0],c1);
    full_adder FA2(A[1],B[1],c1,sum[1],c2);
    full_adder FA3(A[2],B[2],c2,sum[2],c3);
    full_adder FA4(A[3],B[3],c3,sum[3],cout);
endmodule
</code></pre>

<h2>2x2 Multiplier</h2>
<pre><code>
module multiplier_2x2 (input [1:0] A, B, output [3:0] P);
    wire P0, P1, P2, P3;
    wire C1, C2, C3;

    and (P0, A[0], B[0]);
    and (C1, A[1], B[0]);
    and (C2, A[0], B[1]);
    and (C3, A[1], B[1]);
    xor (P1, C1, C2);
    and (P2, C1, C2);
    xor (P3, C3, P2);

    assign P = {P3, P2, P1, P0};
endmodule

module tb_multiplier_2x2();
    reg [1:0] A,B;
    wire [3:0] P;
    multiplier_2x2 uut (.A(A), .B(B), .P(P));
    initial begin
        A=2'b00;B=2'b00;#10;
        A=2'b01;B=2'b10;#10;
        A=2'b11;B=2'b10;#10;
        A=2'b10;B=2'b11;#10;
        $finish;
    end
endmodule
</code></pre>

<h2>JK Flip-Flop</h2>
<pre><code>
module jkff(
    output reg Q,
    output reg QB,
    input J,
    input K,
    input CLK
);
    always @(posedge CLK)
    begin
        case ({J, K})
            2'b00: Q <= Q;
            2'b01: Q <= 1'b0;
            2'b10: Q <= 1'b1;
            2'b11: Q <= ~Q;
        endcase
        QB <= ~Q;
    end
endmodule

`timescale 1ns/1ps
module jkff_TB;
    reg J,K,CLK;
    wire Q,QB;
    jkff uut(.Q(Q),.QB(QB),.J(J),.K(K),.CLK(CLK));
    initial CLK=0;
    always #10 CLK=~CLK;
    initial begin
        J=0;K=0;#20;
        J=0;K=1;#20;
        J=1;K=0;#20;
        J=1;K=1;#20;
        J=0;K=0;#20;
        J=1;K=1;#20;
        $stop;
    end
endmodule
</code></pre>

<h2>T Flip-Flop</h2>
<pre><code>
module t_ff(Q, QB, T, CLK);
    input T, CLK;
    output Q, QB;
    reg Q, QB;
    always @(posedge CLK)
    begin
        if (T)
            Q = ~Q;
        QB = ~Q;
    end
endmodule

module t_ff_TB;
    reg T, CLK;
    wire Q, QB;
    t_ff uut(.Q(Q), .QB(QB), .T(T), .CLK(CLK));
    always #100 CLK = ~CLK;
    initial begin
        CLK=0;
        T=0;
        #200 T=1;
        #200 T=0;
        #200 T=1;
        #200 T=0;
        #200 $stop;
    end
endmodule
</code></pre>

<h2>Shift Register (PISO)</h2>
<pre><code>
module piso(CLK, D, Q, SHIFT_LOAD);
    input CLK, SHIFT_LOAD;
    input [3:0] D;
    output Q;
    reg Q;
    reg [3:0] TEMP;

    always @(posedge CLK)
    begin
        if (SHIFT_LOAD == 1'b0)
        begin
            Q <= 1'b0;
            TEMP <= D;
        end
        else
        begin
            Q <= TEMP[0];
            TEMP <= TEMP >> 1;
        end
    end
endmodule

module piso_tb;
    reg CLK, SHIFT_LOAD;
    reg [3:0] D;
    wire Q;

    piso uut(.CLK(CLK), .D(D), .Q(Q), .SHIFT_LOAD(SHIFT_LOAD));

    initial CLK = 1'b1;
    always #100 CLK = ~CLK;

    initial begin
        D = 4'b1101;
        SHIFT_LOAD = 1'b0; #200;
        SHIFT_LOAD = 1'b1; #1200; D = 4'b1001;
        SHIFT_LOAD = 1'b0; #200;
        SHIFT_LOAD = 1'b1; #1000;
        $stop;
    end
endmodule
</code></pre>

</body>
</html>
